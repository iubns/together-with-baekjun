## 📍 문제 정보

- [#10818. 최소, 최대](https://www.acmicpc.net/problem/2884)
  <img src="https://static.solved.ac/tier_small/2.svg" width="16" height="16">

- **🏷️ 문제 유형**: 수학, 구현, 배열, 정렬, 입출력

---

## 문제

> N개의 정수가 주어진다. 이때, 최솟값과 최댓값을 구하는 프로그램을 작성하시오.
## 입력

>- 첫째 줄에 정수의 개수 N이 주어진다. (1 ≤ N ≤ 1,000,000)
>- 둘째 줄에는 N개의 정수가 공백으로 구분되어 주어진다.
>- 모든 정수는 -1,000,000 이상, 1,000,000 이하이다.

## 출력

> - 첫째 줄에 최솟값과 최댓값을 공백으로 구분해 출력한다.

## 예제 입력

> 5
20 10 35 30 7


## 예제 출력

> 7 35


---

## 📊 풀이 정보

- **⏱️ 소요 시간**: 65분
- **🔄 시도 횟수**: 11회
- **📅 풀이 날짜**: 2025-07-28

---

## 💭 풀이 과정 (ETC)

- 첫 번째 풀이는 min = Integer.MAX_VALUE, max = Integer.MIN_VALUE로 초기화 후 반복문 돌며 비교. 배열은 안 씀.

- 두 번째 풀이는 Arrays.sort()로 정렬 후 arr[0], arr[n-1] 사용. 코드 짧지만 성능 가장 낮음.

- 세 번째 풀이는 비교만 하는 방식이지만 배열을 쓰지 않아 메모리 가장 적음(약 88MB), 시간도 빠름(476ms).

- 네 번째 풀이는 BufferedReader + 배열로 풀었음. 메모리는 준수하지만 시간은 더 오래 걸림 (1268ms).

- 배열을 꼭 써야 하는 상황이 아니라면 입력만 받고 바로 비교하는 방법이 가장 효율적.

- arr[0]로 초기화하고 i=1부터 시작하는 방식도 당연히 가능함. 단, 입력받은 직후에 바로 arr[0]을 기준으로 잡아야 함.


## 🔥 풀이 핵심:  
- 숫자가 많으므로 빠른 입출력(BufferedReader) 고려

- 최소값은 MAX_VALUE로, 최대값은 MIN_VALUE로 초기화하면 비교가 간단함

- 혹은 배열의 첫 번째 값으로 초기화 후 i=1부터 비교하는 것도 OK
(int min = arr[0]; for (int i = 1; i < n; i++) ...)

- 정렬은 구현은 쉬우나 시간/메모리 비효율적

