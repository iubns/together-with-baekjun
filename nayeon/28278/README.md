## 📍 문제 정보

- [#28278. 스택 2](https://www.acmicpc.net/problem/28278)
  <img src="https://static.solved.ac/tier_small/7.svg" width="16" height="16">

- **🏷️ 문제 유형**: 자료구조, 스택

---

## 문제

> 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.

명령은 총 다섯 가지이다.

1 X: 정수 X를 스택에 넣는다. (1 ≤ X ≤ 100,000)
2: 스택에 정수가 있다면 맨 위의 정수를 빼고 출력한다. 없다면 -1을 대신 출력한다.
3: 스택에 들어있는 정수의 개수를 출력한다.
4: 스택이 비어있으면 1, 아니면 0을 출력한다.
5: 스택에 정수가 있다면 맨 위의 정수를 출력한다. 없다면 -1을 대신 출력한다.

## 입력

> 첫째 줄에 명령의 수 N이 주어진다. (1 ≤ N ≤ 1,000,000)

둘째 줄부터 N개 줄에 명령이 하나씩 주어진다.

출력을 요구하는 명령은 하나 이상 주어진다.

## 출력

> 출력을 요구하는 명령이 주어질 때마다 명령의 결과를 한 줄에 하나씩 출력한다.

## 예제 입력

> 9
4
1 3
1 5
3
2
5
2
2
5

## 예제 출력

> 1
2
5
3
3
-1
-1

---

## 📊 풀이 정보

- **⏱️ 소요 시간**: 25분
- **🔄 시도 횟수**: 3회
- **📅 풀이 날짜**: 2025-08-19

---

## 💭 풀이 과정 (ETC)

- 명령 해석:

1 x: stack[++top] = x 로 push

2: 비었으면 -1, 아니면 stack[top--]를 출력 후 제거(“맨 위 정수를 빼고 출력” = pop 값 출력)

3: 크기는 top + 1

4: 비었으면 1, 아니면 0

5: 비었으면 -1, 아니면 stack[top]

- 처음에 cmd 2를 “맨 위를 제거하고 남은 전부 출력”로 오해했으나, 실제 의미는 맨 위 값 하나를 출력하며 제거(pop) 라는 걸 확인하고 로직 수정.

- ++top vs top++ / top-- 동작을 예제로 확인:

stack[++top] = x → 먼저 증가 후 그 칸에 대입(0부터 채워짐)

stack[top--] → 현재 top 값을 사용(출력)한 뒤 top 1 감소

- 시간 초과(TLE)가 떠서 I/O를 교체:

입력: Scanner → BufferedReader

출력: 매번 println → StringBuilder에 모아 한 번에 출력

파싱: line.charAt(0)로 명령 구분, line.substring(2)로 x 빠르게 추출

제약 N ≤ 1,000,000을 고려해 연산 O(1) 유지 및 배열 크기 N 확보.
예제 입력을 대입해 기대 출력과 일치함을 확인.

## 🔥 풀이 핵심:  

- 스택 불변식: top == -1 ⇢ empty, size = top + 1, 맨 위는 stack[top]

- 연산 정의

push: stack[++top] = x

pop: top == -1 ? -1 : stack[top--]

size: top + 1

empty: top == -1 ? 1 : 0

top 조회: top == -1 ? -1 : stack[top]

- I/O 최적화

입력: BufferedReader.readLine()

출력: StringBuilder에 누적 후 한 번에 print

파싱: line.charAt(0)로 명령 분기, substring(2)로 정수 추출(“1 x” 형태)

복잡도: 전체 O(N), 각 명령 O(1) / 메모리 O(N).

