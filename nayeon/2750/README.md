## 📍 문제 정보

- [#2750. 수 정렬하기](https://www.acmicpc.net/problem/2750)
  <img src="https://static.solved.ac/tier_small/2.svg" width="16" height="16">

- **🏷️ 문제 유형**: 구현, 정렬

---

## 문제

> N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

## 입력

> 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.

## 출력

> 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

## 예제 입력

> 5
5
2
3
4
1

## 예제 출력

> 1
2
3
4
5

---

## 📊 풀이 정보

- **⏱️ 소요 시간**: 55분
- **🔄 시도 횟수**: 6회
- **📅 풀이 날짜**: 2025-08-12

---

## 💭 풀이 과정 (ETC)

- 버블정렬

- 인접한 두 원소를 비교해 순서가 반대면 서로 교환(swap)

- 이 과정을 여러 번 패스하면서, 매 패스마다 가장 큰 값이 맨 뒤로 떠오르게 함

- 내부 루프의 비교 범위를 N-1-pass로 점점 축소

- 교환이 한 번도 안 일어난 패스가 있으면 조기 종료

- 삽입정렬

- 배열의 두 번째 원소(i=1) 부터 시작해, 앞쪽 정렬된 구간(0..i-1) 안에서 자신의 위치를 탐색

- 현재 값 key = a[i] 를 보관하고, 앞쪽에서 key보다 큰 값들을 오른쪽으로 한 칸씩 밀기

- 더 이상 밀 필요가 없어지면(왼쪽 끝이거나 a[j] ≤ key) 빈 자리에 key 삽입

- 이 과정을 i = 1..N-1까지 반복


## 🔥 풀이 핵심:  

- (버블정렬) 인덱스 범위: 인접 비교(a[i] vs a[i+1])를 하므로 i는 최대 N-2 까지

- (삽입정렬) j >= 0 : 범위 보호(왼쪽 끝 체크)

- (삽입정렬) a[j] > key : key보다 큰 값만 오른쪽으로 밀기

- (삽입정렬) key를 먼저 보관(오른쪽으로 미는 과정에서 값 소실 방지), 최종 삽입 위치는 j+1

